Skip to main content
Studio
Dashboard
Documentation
open_in_new
incognito
Temporary chat
Your conversation wonâ€™t be saved to Drive
ThinkingThoughts
(experimental)
Auto
Expand to view model thoughts

chevron_right
ThinkingThoughts
(experimental)
Auto
Expand to view model thoughts

chevron_right
ThinkingThoughts
(experimental)
Auto
Expand to view model thoughts

chevron_right
ThinkingThoughts
(experimental)
Auto
Expand to view model thoughts

chevron_right
ThinkingThoughts
(experimental)
Auto
Expand to view model thoughts

chevron_right
ThinkingThoughts
(experimental)
Auto
Expand to view model thoughts

chevron_right
ThinkingThoughts
(experimental)
Auto
Expand to view model thoughts

chevron_right
ThinkingThoughts
(experimental)
Auto
Expand to view model thoughts

chevron_right
ThinkingThoughts
(experimental)
Auto
Expand to view model thoughts

chevron_right
ThinkingThoughts
(experimental)
Auto
Expand to view model thoughts

chevron_right
ThinkingThoughts
(experimental)
Auto
Expand to view model thoughts

chevron_right
Excellent! You have a complete, self-contained Spring Batch job defined in your FileMigrator class. You've defined the Reader, Processor, and Writer, and wired them into a Step and a Job.
Your question, "how to start?", is the final and most important piece of the puzzle. You've built the "assembly line"; now you need to press the "On" button.
There are several ways to start (or "launch") a Spring Batch job. Let's go through the most common ones, from simplest to most flexible.
Prerequisites: Setting Up Your Project
Before you can run the job, make sure your project is ready.
1. Create the Input File
Your FlatFileItemReader is configured to read from src/main/resources/input.txt. You must create this file!
Go to the src/main/resources directory in your project.
Create a new file named input.txt.
Add some lines of text to it:
code
Txt
Hello Spring Batch
This is the second line
We are migrating data from a file
Line four
And the final line
2. Configure a Database for Spring Batch Metadata
Spring Batch requires a database to store the state of your jobs (what ran, when it ran, if it succeeded or failed). The easiest way to get started without installing a full database is to use an in-memory database like H2.
Add the H2 Dependency to your pom.xml:
code
Xml
<dependency>
    <groupId>com.h2database</groupId>
    <artifactId>h2</artifactId>
    <scope>runtime</scope>
</dependency>
Update your application.properties file (src/main/resources/application.properties):
code
Properties
spring.datasource.url=jdbc:h2:mem:batchdb
spring.datasource.driverClassName=org.h2.Driver
spring.datasource.username=sa
spring.datasource.password=password

spring.batch.jdbc.initialize-schema=always
Option 1: The Simplest Way - Run on Application Startup
Spring Boot can automatically run your job as soon as the application starts. This is perfect for simple tests and command-line style applications.
How to do it:
Add the following line to your application.properties file:
code
Properties
spring.batch.job.names=migrateJob
To Run:
Go to your main application class (the one with @SpringBootApplication).
Run the main method.
Watch the console! You will see the Spring Batch logs, including your "GOT THIS" and "::" print statements.
Check the output! A new file, src/main/resources/output.txt, will be created with the exact same content as input.txt.
This is the fastest way to verify your job works.
Option 2: The Most Common Way - Trigger with a REST Controller
In most real-world applications, you want to start a job on demand, not every time the application starts. A REST endpoint is the perfect way to do this.
Step 1: Disable the "Run on Startup" Behavior
First, go back to application.properties and either remove or comment out the spring.batch.job.names property. Or, you can explicitly disable it:
code
Properties
spring.batch.job.enabled=false
Step 2: Create a Controller to Launch the Job
The JobLauncher is the Spring Batch component responsible for starting jobs. We will inject it into a controller.
Create a new class, JobController.java:
code
Java
package com.example.demo;

import org.springframework.batch.core.Job;
import org.springframework.batch.core.JobParameters;
import org.springframework.batch.core.JobParametersBuilder;
import org.springframework.batch.core.launch.JobLauncher;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class JobController {

    @Autowired
    private JobLauncher jobLauncher;

    @Autowired
    @Qualifier("migrateJob") // Use @Qualifier to specify which Job bean to inject
    private Job migrateJob;

    @PostMapping("/start-job")
    public String startJob() {
        try {
            // Each job run must have unique parameters to be considered a new instance.
            // Using the current time is a common and simple way to ensure uniqueness.
            JobParameters jobParameters = new JobParametersBuilder()
                    .addLong("time", System.currentTimeMillis())
                    .toJobParameters();

            jobLauncher.run(migrateJob, jobParameters);
            return "Batch job has been invoked";
        } catch (Exception e) {
            return "Error starting batch job: " + e.getMessage();
        }
    }
}
To Run:
Start your main Spring Boot application. It will start up and wait.
Open a tool like Postman, or use your command line with curl.
Send a POST request to http://localhost:8080/start-job.
code
Bash
curl -X POST http://localhost:8080/start-job
You will get an immediate response: "Batch job has been invoked".
Check your application console logs. You will see the job running.
Check for the output.txt file.
Code Review & Best Practices for FileMigrator.java
Your code is functional, but we can make it cleaner and more aligned with modern Spring practices.
Use @Configuration instead of @Component: For classes that mainly define @Beans, @Configuration is more idiomatic and clearly states the class's purpose.
Use Method Parameter Injection: Instead of @Autowired fields, inject dependencies directly into the @Bean methods that need them. This is cleaner and makes dependencies explicit.
Here is your refactored FileMigrator class with these improvements:
code
Java
package com.example.demo;

import org.springframework.batch.core.Job;
import org.springframework.batch.core.Step;
import org.springframework.batch.core.configuration.annotation.StepScope;
import org.springframework.batch.core.job.builder.JobBuilder;
import org.springframework.batch.core.launch.support.RunIdIncrementer;
import org.springframework.batch.core.repository.JobRepository;
import org.springframework.batch.core.step.builder.StepBuilder;
import org.springframework.batch.item.ItemProcessor;
import org.springframework.batch.item.file.FlatFileItemReader;
import org.springframework.batch.item.file.FlatFileItemWriter;
import org.springframework.batch.item.file.builder.FlatFileItemReaderBuilder;
import org.springframework.batch.item.file.builder.FlatFileItemWriterBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration; // Changed from @Component
import org.springframework.core.io.FileSystemResource;
import org.springframework.transaction.PlatformTransactionManager;

@Configuration // More idiomatic for bean definitions
public class FileMigrator {

    // Reader, Writer, and Processor beans are perfect as they are.
    @Bean
    @StepScope
    public FlatFileItemReader<String> reader() {
        return new FlatFileItemReaderBuilder<String>().name("reader-name")
                .resource(new FileSystemResource("src/main/resources/input.txt"))
                .lineMapper((line, lineNumber) -> line)
                .build();
    }

    @Bean
    @StepScope
    public FlatFileItemWriter<String> writer() {
        return new FlatFileItemWriterBuilder<String>().name("writer-name")
                .resource(new FileSystemResource("src/main/resources/output.txt"))
                .lineAggregator(item -> item) // Simplified line aggregator
                .build();
    }

    @Bean
    @StepScope
    public ItemProcessor<String, String> processor() {
        return item -> {
            System.out.println("Processing item: " + item);
            return item.toUpperCase(); // Let's make the processor do something!
        };
    }

    @Bean
    public Step migrateStep(JobRepository jobRepository,
                            PlatformTransactionManager platformTransactionManager,
                            FlatFileItemReader<String> reader,
                            ItemProcessor<String, String> processor,
                            FlatFileItemWriter<String> writer) {
        // No more (Step) cast needed, build() returns the correct type.
        return new StepBuilder("step-name", jobRepository)
                .<String, String>chunk(5, platformTransactionManager)
                .reader(reader)
                .processor(processor)
                .writer(writer)
                .build();
    }

    @Bean
    public Job migrateJob(JobRepository jobRepository, Step migrateStep) {
        // Inject dependencies directly into the method.
        // This is cleaner than using @Autowired fields.
        return new JobBuilder("migrateJob", jobRepository)
                .incrementer(new RunIdIncrementer())
                .start(migrateStep) // Pass the Step bean as an argument
                .build();
    }
}
37.3s
warning
Turn Drive on for future conversations
Your work is currently not being saved and will be lost, we recommend enabling Google Drive, you will always have the option to turn on Temporary chat for conversations you do not want to save to your chat history.
Start typing a prompt

Run
1




notifications
Copied to clipboard
